## Functions for porteus init
## Author brokenman, modified for Debiandog by fredx181
# 2024-03-18 fredx181 modified for pseudo-full install

# Modified by gumanzoy https://github.com/PocketHandyBox

# Export some color functions
RED='\033[0;31m'
GREEN='\033[0;32m'
CYAN='\033[0;36m'
YELLOW='\033[1;33m'
BOLD='\033[1;37m'
RST='\033[0m' # Reset Color

# Load network kernel modules for PXE boot
load_net_modules() {
#softdep for r8169 https://bugzilla.kernel.org/show_bug.cgi?id=204343
lspci | grep 0200: >/tmp/lspci
grep -q 10ec: /tmp/lspci && modprobe -q realtek
grep -q 14e4: /tmp/lspci && modprobe -q broadcom
for x in `cut -d: -f3-4 /tmp/lspci | sed s/:/.*/g | tr a-z A-Z`; do
	modprobe -q `grep $x /lib/modules/$(uname -r)/modules.alias | tail -n1 | rev | cut -d" " -f1 | rev`
done
if [ -z "`ls /sys/class/net | grep eth`" ]; then
	for x in `find /lib/modules/$(uname -r)/kernel/drivers/net/ethernet -name "*.ko" | sed 's/.ko//g'`
	do modprobe -q `basename $x`
	ls /sys/class/net | grep -q eth && break || rmmod `basename $x` 2>/dev/null
	done
fi
}

# Run fstab for setup
fstab() {
rm -f /tmp/devices
param nocd || for x in /dev/sr*; do blkid $x >>/tmp/devices; done
param nohd || blkid | egrep -v '/dev/sr|/dev/loop|/dev/mapper' >>/tmp/devices
dev=`egrep -v 'TYPE="sw|TYPE="LVM|TYPE=".*_raid_member"' /tmp/devices 2>/dev/null | cut -d: -f1 | cut -d/ -f3 | sort | uniq`
cat > /etc/fstab << EOF
# Do not edit this file as fstab is recreated automatically during every boot.
# Please use /etc/rc.d/rc.local or sysvinit scripts if you want to mount/unmount
# drive, filesystem or network share.

# System mounts:
#aufs / aufs defaults 0 0
overlay / overlay 0 0

proc /proc proc defaults 0 0
sysfs /sys sysfs defaults 0 0
devtmpfs /dev devtmpfs defaults 0 0
devpts /dev/pts devpts rw,mode=0620,gid=5 0 0

# Device partitions:
EOF
for x in $dev; do
fs=`grep -w /dev/$x /tmp/devices | egrep -o ' TYPE=[^ ]+' | cut -d'"' -f2`
if [ $fs = vfat ]; then
	echo "/dev/$x /mnt/$x vfat $MOPT,umask=0,check=s,utf8 0 0" >> /etc/fstab
elif [ $fs = ntfs ] && grep -q ntfs3 /proc/filesystems ; then
	echo "/dev/$x /mnt/$x ntfs3 $MOPT,force,sparse 0 0" >> /etc/fstab
elif [ $fs = ntfs ]; then
	echo "/dev/$x /mnt/$x ntfs $MOPT,umask=0,nls=utf8 0 0" >> /etc/fstab
else
	echo "/dev/$x /mnt/$x $fs $MOPT 0 0" >> /etc/fstab
fi
if [ ! -d /mnt/$x ]; then
	mkdir /mnt/$x
	mount -n /mnt/$x 2>/dev/null || { modprobe -q $fs && mount -n /mnt/$x 2>/dev/null || { sed -i "/$x /d" /etc/fstab; rmdir /mnt/$x; }; }
fi
# Old code for FAT/NTFS
#    [ $fs = vfat ] && echo "/dev/$x /mnt/$x vfat $MOPT,umask=0,check=s,utf8 0 0" >>/etc/fstab || echo "/dev/$x /mnt/$x $fs $MOPT 0 0" >>/etc/fstab
#    if [ ! -d /mnt/$x ]; then
#	mkdir /mnt/$x
#	if [ $fs = ntfs ]; then
#	    ntfs-3g /dev/$x /mnt/$x -o $MOPT 2>/dev/null || { sed -i "/$x /d" /etc/fstab; rmdir /mnt/$x; }
#	else
#	    mount -n /mnt/$x 2>/dev/null || { modprobe $fs 2>/dev/null && mount -n /mnt/$x 2>/dev/null || { sed -i "/$x /d" /etc/fstab; rmdir /mnt/$x; }; }
#	fi
#    fi
done

if [ -z "`egrep -o " noswap( |\$)" /proc/cmdline`" -a -e /tmp/devices ]; then
	#echo -e "\n# Swap partitions:" >>/etc/fstab
	for x in `grep 'TYPE="swap"' /tmp/devices | cut -d: -f1`; do echo "$x none swap sw,pri=1 0 0" >>/etc/fstab; done
fi
}

# Mount things
mount_device() {
fs=`blkid /dev/$1 | egrep -o ' TYPE=[^ ]+' | cut -d'"' -f2`
[ "$fs" ] || return 0
mkdir /mnt/$1
if [ $fs = vfat ]; then
	mount -n /dev/$1 /mnt/$1 -o $MOPT,umask=0,check=s,utf8 2>/dev/null || rmdir /mnt/$1
elif [ $fs = ntfs ] && grep -q ntfs3 /proc/filesystems ; then
	mount -n /dev/$1 /mnt/$1 -t ntfs3 -o $MOPT,force,sparse 2>/dev/null || rmdir /mnt/$1
elif [ $fs = ntfs ]; then
	mount -n /dev/$1 /mnt/$1 -o $MOPT,umask=0,nls=utf8 2>/dev/null || rmdir /mnt/$1
#	ntfs-3g /dev/$1 /mnt/$1 -o $MOPT 2>/dev/null || rmdir /mnt/$1
else
	mount -n /dev/$1 /mnt/$1 -o $MOPT 2>/dev/null || { modprobe -q $fs && mount -n /dev/$1 /mnt/$1 -o $MOPT || rmdir /mnt/$1; }
fi
}

# Search for boot location
search() { FND=none; for x in `ls /mnt | tac`; do
[ $1 /mnt/$x/$2 ] && { DEV=$x; FND=y; break; }; done
[ $FND = y ]; }

# Delay booting a little until devices have settled
nap() { echo -en $i"device not ready yet? delaying [1;33m$SLEEP[0m seconds \r"; sleep 1; }
lazy() { SLEEP=6; while [ $SLEEP -gt 0 -a $FND = none ]; do nap; let SLEEP=SLEEP-1; fstab; search $*; done }

# Find location of Porteus files
locate() { LPATH=`echo $2 | cut -b-5 | sed s@/dev@/mnt@`
if [ $LPATH = /mnt/ ]; then
    DEV=`echo $2 | cut -d/ -f3`; LPTH=`echo $2 | cut -d/ -f4-`; SLEEP=6
    while [ $SLEEP -gt 0 -a ! -b /dev/$DEV ]; do nap; let SLEEP=SLEEP-1; fstab; done
    [ -d /mnt/$DEV ] || mount_device $DEV
    [ $1 /mnt/$DEV/$LPTH ]
elif [ $LPATH = UUID: -o $LPATH = LABEL ]; then
    ID=`echo $2 | cut -d: -f2 | cut -d/ -f1`; LPTH=`echo $2 | cut -d/ -f2-`; DEV=`blkid | grep $ID | cut -d: -f1 | cut -d/ -f3`; SLEEP=6
    while [ $SLEEP -gt 0 -a "$DEV" = "" ]; do nap; let SLEEP=SLEEP-1; fstab; DEV=`blkid | grep $ID | cut -d: -f1 | cut -d/ -f3`; done
    [ -d /mnt/$DEV ] || mount_device $DEV
    [ $1 /mnt/$DEV/$LPTH ]
else
    LPTH=$2; search $* || lazy $*
fi }

# Check if a location is writable
is_writable(){ touch $1/.test 2>/dev/null; [ -e $1/.test ] && rm $1/.test; }

# Booting failed. Failed to find porteus files. 
fail() { echo -e $i"couldn't find $1. Correct your from= cheatcode.\n Documentation in /usr/doc/porteus. Press 'enter' to continue booting."; read -s; }

# Failed to initiate changes. Creating temporary changes on tmpfs for this session.
fail_chn() { mount -nt tmpfs -o size=$RAMSIZE tmpfs /memory/changes; CHANGES=memory; CHNDEV=memory; touch /etc/nochanges; }

# Just draw a line
draw() { echo "[1;33m""---------------------------------------------------------""[0m"; }

# Copy modules
cpmod() { NUM=`grep -c '.' $1`
modfile=$1
while read x; do
    echo -en "[1;33m""  ($NUM modules left)  \r""[0m"; let NUM=NUM-1; NAME=`basename "$x"`
    cp "$x" /memory/copy2ram 2>/dev/null
    if [ $? -eq 0 ]; then
	sed -i s@^.*/$NAME@/memory/copy2ram/$NAME@ /tmp/modules
    else
	rm /memory/copy2ram/"$NAME"; echo -e $i"[1;36m""Not enough memory to copy $NAME""[0m"; echo -e $i"[1;36m""Other modules will be skipped.""[0m"
	find /memory/copy2ram -name "*.kmodsfs" | sort >/tmp/modules
	find /memory/copy2ram -name "*.squashfs" | sort >>/tmp/modules
	break
    fi
done < $modfile
echo -en "                       \r"
}

# If bootlog cheatcode is present then make log entry
blog(){
		param log && echo "$1" >> $LOGFILE
}

# Check for a boot param
#chk_bootcfg(){ grep "^$1" /union/etc/bootcmd.cfg; }

#======================================
# setClean
#--------------------------------------
setClean()
{
[ $PFULL ] && UDIR=filesystem || UDIR=upperdir
#=== 変分反映層
	mkdir -p /memory/changes/$UDIR
#=== 変分管理データ層
	mkdir -p /memory/changes/workdir

#--<継承エリア初期化>--#
local PLACE=/memory/changes/$UDIR
#	rm -rf $PLACE/boot 2>/dev/null
	rm -rf $PLACE/dev 2>/dev/null
	rm -rf $PLACE/mnt 2>/dev/null
	rm -rf $PLACE/proc 2>/dev/null
	rm -rf $PLACE/run 2>/dev/null
	rm -rf $PLACE/sys 2>/dev/null
	rm -rf $PLACE/tmp 2>/dev/null
	rm -rf $PLACE/var/lock/* 2>/dev/null
	rm -rf $PLACE/var/run 2>/dev/null
	rm -rf $PLACE/var/tmp 2>/dev/null
	rm -rf $PLACE/var/spool/cron/cron.?????? 2>/dev/null

#	chown -R guest:users $PLACE/home/guest 2>/dev/null

#--< activate 後 deactivate 無しで終了した残骸を削除する >--#
#--- delete symbolic link setting "entity & tag" ---#
local x
local DIR
local PKG
	for x in `find $PLACE -name '.act.new.*' `
	do
		DIR=${x%/*}
		PKG=${x##*/}
		PKG=${PKG#.act.new.}
#echo "x=$x DIR=$DIR PKG=$PKG" 
		if [ -h $DIR/$PKG ]
		then
			rm $DIR/$PKG
		fi
		rm $x
	done

#--- recover original entity ---#
	for x in `find $PLACE -name '.act.org.*' `
	do
#		DIR=${x%/*}
#		PKG=${x##*/}
#		PKG=${PKG#.act.org.}
#		mv $x $DIR/$PKG
		rm $x
	done
}
#======================================
# IncludeModules
#--------------------------------------
IncludeModules()
{
[ $PFULL ] && UDIR=filesystem || UDIR=upperdir
echo yes > /etc/pfull-compat
#=== 変分反映層
mkdir -p /memory/changes/$UDIR
UPPERDIR=/memory/changes/$UDIR
#=== 変分管理データ層
mkdir -p /memory/changes/workdir
WORKDIR=/memory/changes/workdir

#--<継承エリア初期化>--#
setClean

#=== 固定不変層
LOWLIST=""
a=2
for x in `cat /tmp/modules`;
do
    ############### truncate mountpoint names ############## fred181 mod 231020 for 01-filesystem.squashfs
    #   NAME=`basename $x`; //ORIGINAL line
    if [ "$(basename $x)" = "01-filesystem.squashfs" ]; then  #fred181 mod 231020 keep name 01-filesystem.squashfs
if [ $PFULL ] && [ -d /mnt/$DEV/$LPTH/pfull ]; then
continue
else
NAME=`basename $x`;
fi
	else
        NAME=`basename ${x%.*}`; # remove extension .squashfs
        #NAME="${NAME:0:14}""-$a" # initial OK 
        #NAME="${NAME:0:14}""-$a"".squashfs" fix PROBLEM returned too many filename characters
        NAME="${NAME:0:9}""-$a"".squashfs"
	    # skip if (truncated) /memory/images/$NAME exists already
	    [ -d /memory/images/$NAME ] && continue
	    let a=a+1
 	fi
    #########################################################
	mkdir /memory/images/$NAME;
	mount -o loop $x /memory/images/$NAME 2>/dev/null
	if [ $? -eq 0 ];
	then
		echo "  $m  `basename $x`";
		LOWLIST=/memory/images/${NAME}:${LOWLIST}
	else
		echo $i"[1;36m""Cannot read $NAME - corrupted module?""[0m";
		rmdir /memory/images/$NAME
	fi
done
if [ -z "$(echo "${LOWLIST}" | grep 01-filesystem.squashfs)" ]; then
mkdir -p "/memory/images/01-filesystem.squashfs"
LOWLIST=/memory/images/01-filesystem.squashfs:${LOWLIST}
fi

if [ -d /memory/images/changes-exit ]
then
	LOWLIST=/memory/images/changes-exit/$UDIR:${LOWLIST}
	cp -a /memory/images/changes-exit/workdir/* $WORKDIR/. 2> /dev/null
fi
LOWLIST=`echo $LOWLIST | sed 's/:$//'`

#echo "mount -t overlay -o upperdir=$UPPERDIR,lowerdir=$LOWLIST,workdir=$WORKDIR overlay /union"
mount -t overlay -o upperdir=$UPPERDIR,lowerdir=$LOWLIST,workdir=$WORKDIR overlay /union
if [ $? -ne 0 ]
then
	sh
fi
}

